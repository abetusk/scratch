Computer Science Major Arcana
===

From [src](https://www.tumblr.com/eyepool/722652304002678784/computer-science-major-arcana)

0. Hello World (Corresponds to The Fool.) The traditional first program written in any computer language just prints “Hello World”. Fits with the idea of naïveté and starting-out.
1. NULL Nothing, void. The value that is no value. In many languages NULL is a Pointer that causes a Crash if used.
2. Lambda captures the idea of a function, a fundamental operation. Lambda has no name but enacts change. Alonzo Church’s Lambda Calculus predates digital computers but was in the 1960s implemented pretty much directly as the seminal language LISP.
3. Recursion A function that calls itself … a concept defined in terms of itself … a story about the person telling the story. A spooky strange loop.
4. The Crash The impossible has occurred and things cannot continue.
5. Deadlock A cannot proceed until B finishes, but B cannot proceed until A finishes. A tangle of responsibilities. Not a crash exactly, but time has stopped.
6. The Pointer A value that just tells you where another value is. Indirection. Some pointers don’t point to any value … they may be NULL or may be Bad.
7. The Namespace Giving names to things, as Adam did, is a fundamental part of creation. Once named, the distinction between the thing and the name of the thing becomes spooky. “There are only two hard problems in computer science: cache invalidation and naming things” —Phil Karlton
8. The Cache The cache is memory. The cache takes that which was arrived at by labor, and saves it for easy re-use … by naming it. A cache is temporary, but when the thing cached is no longer valid, how does the cache know to forget it? (See above quote.)
9. The Class We group similar thing together, and the grouping becomes its own thing. What is the concept of “Dog”? A class. It isn’t a dog. It isn’t any concrete thing at all. It isn’t even the same as the name “Dog” (or “Chien”.) And what is the class of all classes but the edge of an infinite regress…
10. Iteration “Do these things, then do them again.” The second program we learn to write is a loop that spews “Hello!” infinitely. Some loops are finite and some are infinite, and no computer can tell the difference, says Turing. The windmill peacefully grinding grain is a loop, but so is the sorcerer’s apprentice’s buckets flooding the castle.
11. The Bug The computer does exactly what the program told it to do. It’s our fault that we’re not smart enough to fully comprehend any program that’s big enough to be interesting. We rush forward to say hello to new worlds we design – later on we find that what we said isn’t exactly what we meant.
12. Undefined Behavior: You have transgressed the Law, but were not lucky enough to Crash. The Specification no longer protects you, the rules no longer apply, anything whatsoever may now occur. Carry holy Kleenex.
13. The Monad: Change that is not change, time wrapped in timelessness.
14. The Assertion: It tells right from wrong, success from failure. Heed its warnings.
15. Continuous Integration: The stakes in the ground, the early warning system (see The Assertion.) This is the progress you have made, there will be no backsliding.
16. P vs NP: Some things take a long time. Some things take a very, very long time. No one knows which is which.
